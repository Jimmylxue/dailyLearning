<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>函数拥有多个长辈</title>
</head>
<body>
  <script>
    function User(){}
    console.dir(User)
    User.__proto__.show1 = ()=>{
      console.log('服务于对象的原型方法')
    }
    let Jimmy = new User()
    try {
      Jimmy.show1()
    } catch (error) {
      console.log(error.message) // Jimmy.show1 is not a function
      // 可见 由构造函数实例化出来的对象，是不可以使用函数本身.__proto__上面的方法的 因为本质上他们不在同一条原型链上
    }

    User.prototype.show2 = ()=>{
      console.log('构造函数原型对象')
    }
    Jimmy.show2() // 构造函数原型对象
    console.log(Jimmy)
    console.log(Jimmy.__proto__ == User.prototype) // TRUE

  </script>
</body>
</html>