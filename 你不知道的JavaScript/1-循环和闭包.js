/**
 * 闭包随处可见，只是我们过去并不认识它
 *  当函数在它本身词法作用域外执行 就会产生闭包
 *  函数当作一种值类型进行传递，这个也是闭包的应用
 *  在 定时器、事件监听器、网络请求、等等的异步任务中们只要使用了回调函数 记住！  实际上就是在使用闭包！！！！！！!
 */
for (var i = 0; i <= 5; i++) {
  /**
   * 解释：
   *  setTimeOut(fn,time) 除了 fn回调函数的部分是异步的 其他执行 这个 setTimeout()是同步执行的 所以这时候的 i*1000 就是 0 1000 2000 3000.....
   *  只是因为var创建的i在for循环的过程中本质上是被封闭在同一个共享的作用域中 所以 i一直在被覆盖  在执行回调函数的时候  i已经被覆盖成 6 了
   *  所以就是 每个1秒 输出一次 6
   */
  setTimeout(function () {
    console.log(i);
  }, i * 1000);
}
/**
 * 以上的代码会每隔一秒钟输出一次6 输出6次
 */

for (var i = 0; i <= 5; i++) {
  (function () {
    /**
     * 这里显然我们有了更多的词法作用域了 但是本质上是空的作用域
     *  如果作用域是空的，那么仅仅对他封闭起来是不够的
     *  这里输出的结果任然是  每秒输出一次6
     */
    setTimeout(() => {
      console.log(i);
    }, i * 1000);
  })();
}

for (var i = 0; i <= 5; i++) {
  (function () {
    /**
     * 这里这样就可以了  我们不仅创建了很多的IIFE 创建了很多的作用域
     *  最重要的是这些作用域都不是空的 都有自己存储值 因为回调函数（闭包）存在的关系 这些值会被一直保留 并不会被垃圾回收机制所回收
     *  但是代码任然是可以再进行优化的
     */
    var j = i;
    setTimeout(() => {
      console.log(j);
    }, j * 1000);
  })();
}

for (var i = 0; i <= 5; i++) {
  (function (j) {
    /**
     * 这里使用 传参的形式  内部也是 var j = i  但是代码更加的简洁了
     * 这里这样就可以了  我们不仅创建了很多的IIFE 创建了很多的作用域
     *
     * 再写一遍 这里能实现的原因是  我们创建了很多额 IIFE IIFE都是有自己的作用域的
     *  我们将值传给了 IIFE 本来 IIFE在执行结束之后就会触发垃圾回收 回收掉没用的数据
     *  但是因为有回调函数的缘故，任何有回调函数的地方本质上都是 闭包  因为闭包的存在 所以这里的传参的值得以被保存了下来
     *  就实现了 每秒输出一次的逻辑了
     */
    setTimeout(() => {
      console.log(j);
    }, j * 1000);
  })(i);
}

for (let i = 0; i <= 5; i++) {
  // 当然到了ES6就不用那么为难的处理了 let和{}可以轻松的实现块级作用域了  代码最优雅！！
  setTimeout(function () {
    console.log(i);
  }, i * 1000);
}

/**
 * 使用let 因为在for中 使用let定义会使得每个let都有自己的作用域 所以结果就是我们想要的  输出 0到5
 */
